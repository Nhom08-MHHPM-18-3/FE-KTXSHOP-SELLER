{"ast":null,"code":"import _regeneratorRuntime from \"/home/hao/Deadline/mhhpm_18_3_final/FE-KTXSHOP-SELLER/node_modules/next/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/home/hao/Deadline/mhhpm_18_3_final/FE-KTXSHOP-SELLER/node_modules/next/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\nvar _s = $RefreshSig$();\n\n/*\nThis function return a session string by parsing cookie value of incoming request.\n */\nimport { useRouter } from \"next/router\";\nimport { APIStatus } from \"./common\";\nexport function getSessionToken(ctx, cookieName) {\n  cookieName = cookieName || \"session_token\";\n  var sessionStr = ctx.req && ctx.req.headers.cookie;\n  var session = undefined;\n\n  if (sessionStr) {\n    sessionStr.split(\";\").forEach(function (cookie) {\n      var i = cookie.indexOf(\"=\");\n      var name = cookie.substr(0, i).trim();\n      var value = cookie.substr(i + 1).trim();\n\n      if (name == cookieName) {\n        session = value;\n        return false;\n      }\n    });\n  }\n\n  return session;\n}\n\nfunction getLoggedUserInfo(_x) {\n  return _getLoggedUserInfo.apply(this, arguments);\n}\n/**\n * This function is used by injecting to getServerSideProps of pages.\n * @param ctx\n * @param callback\n * @returns {Promise<*|{props: {loggedIn: boolean}}>}\n */\n\n\nfunction _getLoggedUserInfo() {\n  _getLoggedUserInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(ctx) {\n    var session, res, req, url;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            session = getSessionToken(ctx); // if there is not cookie with \"session_token\" name\n\n            res = ctx.res;\n\n            if (!(!session || session === \"deleted\")) {\n              _context.next = 10;\n              break;\n            }\n\n            session = getSessionToken(ctx, \"remember_me\");\n\n            if (!(!session || session === \"deleted\")) {\n              _context.next = 9;\n              break;\n            }\n\n            res.setHeader(\"location\", \"/login?url=\" + escape(ctx.req.url));\n            res.statusCode = 302;\n            res.end();\n            return _context.abrupt(\"return\", {\n              props: {\n                loggedIn: false\n              }\n            });\n\n          case 9:\n            res.setHeader(\"set-cookie\", \"session_token=\".concat(session, \"; Path=/; HttpOnly\"));\n\n          case 10:\n            // if there is value\n            req = {\n              method: \"GET\",\n              headers: {\n                \"Authorization\": \"Bearer \".concat(session),\n                \"User-Agent\": ctx.req.headers['user-agent'],\n                'X-Forwarded-For': ctx.req.headers['x-forwarded-for']\n              }\n            };\n            url = process.env.API_HOST + \"/core/account/v1/me?getPermissions=true\";\n            _context.next = 14;\n            return fetch(url, req);\n\n          case 14:\n            return _context.abrupt(\"return\", _context.sent);\n\n          case 15:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _getLoggedUserInfo.apply(this, arguments);\n}\n\nexport function doWithLoggedInUser(_x2, _x3) {\n  return _doWithLoggedInUser.apply(this, arguments);\n}\n/**\n * This function is used by injecting to render function of pages.\n * @param props\n * @param callback\n * @returns {null|*}\n */\n\nfunction _doWithLoggedInUser() {\n  _doWithLoggedInUser = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(ctx, callback) {\n    var result;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            // let result = await getLoggedUserInfo(ctx)\n            // let userInfo = await result.json()\n            // // must get user info successful before do anything else\n            // // console.log(userInfo)\n            // if (userInfo.status !== APIStatus.OK) {\n            //     return { props: { loggedIn: false } }\n            // }\n            // // check temp password\n            // let source = userInfo.data[0]\n            // let account = source.account\n            // if (!ctx.req.url.startsWith('/profile') && account.isTempPassword) {\n            //     if (typeof window === \"undefined\") {\n            //         let res = ctx.res\n            //         res.setHeader(\"location\", \"/profile\");\n            //         res.statusCode = 302;\n            //         res.end();\n            //     }\n            //     return { props: { loggedIn: true, loggedInUserInfo: source } }\n            // }\n            result = callback(ctx); // // wait for page promise\n\n            if (!(result && result instanceof Promise)) {\n              _context2.next = 5;\n              break;\n            }\n\n            _context2.next = 4;\n            return result;\n\n          case 4:\n            result = _context2.sent;\n\n          case 5:\n            // // set loggedIn = true if is is undefined\n            result = result || {};\n            result.props = result.props || {}; // result.props.loggedInUserInfo = userInfo.data[0]\n            // if (typeof result.props.loggedIn == \"undefined\") {\n\n            result.props.loggedIn = true; // }\n\n            return _context2.abrupt(\"return\", result);\n\n          case 9:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _doWithLoggedInUser.apply(this, arguments);\n}\n\nexport function renderWithLoggedInUser(props, callback) {\n  _s();\n\n  var router = useRouter(); // if logged in\n\n  if (props.loggedIn !== false) {\n    // validate permissions\n    var source = props.loggedInUserInfo;\n\n    if (source) {\n      // check temp password\n      if (!router.asPath.startsWith(\"/profile\") && source.account && source.account.isTempPassword) {\n        if (true) {\n          window.location.href = \"/profile\";\n        }\n\n        return callback(props);\n      }\n    }\n\n    return callback(props) || null;\n  } // if not\n  else {\n      // do hard redirect to /login\n      if (true) {\n        window.location.href = \"/login?url=\" + router.asPath;\n      }\n    }\n\n  return null;\n}\n/**\n * \n */\n\n_s(renderWithLoggedInUser, \"fN7XvhJ+p5oE6+Xlo0NJmXpxjC8=\", false, function () {\n  return [useRouter];\n});\n\nexport function doLogout() {\n  return _doLogout.apply(this, arguments);\n}\n\nfunction _doLogout() {\n  _doLogout = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.next = 2;\n            return fetch(\"/backend/core/account/v1/logout\", {\n              method: \"PUT\"\n            });\n\n          case 2:\n            return _context3.abrupt(\"return\", _context3.sent);\n\n          case 3:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _doLogout.apply(this, arguments);\n}\n\nfunction comparePath(input, permission) {\n  if (permission.startsWith(\"=\")) {\n    if (input === permission.substr(1)) {\n      return true;\n    }\n  } else if (input.startsWith(permission)) {\n    return true;\n  }\n\n  return false;\n}\n\nexport function acceptedScreenPath(userInfo, path) {\n  if (!userInfo) {\n    return false;\n  }\n\n  if (path == \"/\" || path == \"/profile\") {\n    return true;\n  }\n\n  var screens = userInfo.screens;\n  var userRoles = userInfo.userRoles;\n  var accepted = false;\n\n  if (screens) {\n    for (var i = 0; i < screens.length; i++) {\n      if (screens[i].indexOf(\":departmentCode\") >= 0) {\n        for (var j = 0; userRoles && j < userRoles.length; j++) {\n          var normalizedPath = screens[i].replace(\":departmentCode\", userRoles[j].departmentCode);\n\n          if (comparePath(path, normalizedPath)) {\n            accepted = true;\n            break;\n          }\n        }\n      } else {\n        if (comparePath(path, screens[i])) {\n          accepted = true;\n          break;\n        }\n      }\n    }\n  }\n\n  return accepted;\n}","map":{"version":3,"sources":["/home/hao/Deadline/mhhpm_18_3_final/FE-KTXSHOP-SELLER/lib/login.js"],"names":["useRouter","APIStatus","getSessionToken","ctx","cookieName","sessionStr","req","headers","cookie","session","undefined","split","forEach","i","indexOf","name","substr","trim","value","getLoggedUserInfo","res","setHeader","escape","url","statusCode","end","props","loggedIn","method","process","env","API_HOST","fetch","doWithLoggedInUser","callback","result","Promise","renderWithLoggedInUser","router","source","loggedInUserInfo","asPath","startsWith","account","isTempPassword","window","location","href","doLogout","comparePath","input","permission","acceptedScreenPath","userInfo","path","screens","userRoles","accepted","length","j","normalizedPath","replace","departmentCode"],"mappings":"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","sourcesContent":["/*\nThis function return a session string by parsing cookie value of incoming request.\n */\nimport { useRouter } from \"next/router\";\nimport { APIStatus } from \"./common\";\n\nexport function getSessionToken(ctx, cookieName) {\n    cookieName = cookieName || \"session_token\"\n    let sessionStr = ctx.req && ctx.req.headers.cookie\n    let session = undefined\n    if (sessionStr) {\n        sessionStr.split(\";\").forEach((cookie) => {\n            let i = cookie.indexOf(\"=\")\n            let name = cookie.substr(0, i).trim()\n            let value = cookie.substr(i + 1).trim()\n            if (name == cookieName) {\n                session = value\n                return false\n            }\n        })\n    }\n    return session\n}\n\nasync function getLoggedUserInfo(ctx) {\n    let session = getSessionToken(ctx)\n\n    // if there is not cookie with \"session_token\" name\n    let res = ctx.res\n    if (!session || session === \"deleted\") {\n        session = getSessionToken(ctx, \"remember_me\")\n        if (!session || session === \"deleted\") {\n            res.setHeader(\"location\", \"/login?url=\" + escape(ctx.req.url));\n            res.statusCode = 302;\n            res.end();\n            return { props: { loggedIn: false } }\n        }\n\n        res.setHeader(\"set-cookie\", `session_token=${session}; Path=/; HttpOnly`)\n    }\n\n    // if there is value\n    let req = {\n        method: \"GET\",\n        headers: {\n            \"Authorization\": `Bearer ${session}`,\n            \"User-Agent\": ctx.req.headers['user-agent'],\n            'X-Forwarded-For': ctx.req.headers['x-forwarded-for']\n        }\n    }\n    let url = process.env.API_HOST + \"/core/account/v1/me?getPermissions=true\"\n    return await fetch(url, req)\n}\n\n/**\n * This function is used by injecting to getServerSideProps of pages.\n * @param ctx\n * @param callback\n * @returns {Promise<*|{props: {loggedIn: boolean}}>}\n */\nexport async function doWithLoggedInUser(ctx, callback) {\n    // let result = await getLoggedUserInfo(ctx)\n    // let userInfo = await result.json()\n\n    // // must get user info successful before do anything else\n    // // console.log(userInfo)\n    // if (userInfo.status !== APIStatus.OK) {\n    //     return { props: { loggedIn: false } }\n    // }\n\n    // // check temp password\n    // let source = userInfo.data[0]\n    // let account = source.account\n\n    // if (!ctx.req.url.startsWith('/profile') && account.isTempPassword) {\n    //     if (typeof window === \"undefined\") {\n    //         let res = ctx.res\n    //         res.setHeader(\"location\", \"/profile\");\n    //         res.statusCode = 302;\n    //         res.end();\n    //     }\n    //     return { props: { loggedIn: true, loggedInUserInfo: source } }\n    // }\n\n    let result = callback(ctx)\n    // // wait for page promise\n    if (result && result instanceof Promise) {\n        result = await result\n    }\n\n    // // set loggedIn = true if is is undefined\n    result = result || {}\n    result.props = result.props || {}\n    // result.props.loggedInUserInfo = userInfo.data[0]\n    // if (typeof result.props.loggedIn == \"undefined\") {\n    result.props.loggedIn = true\n    // }\n    return result\n}\n\n/**\n * This function is used by injecting to render function of pages.\n * @param props\n * @param callback\n * @returns {null|*}\n */\nexport function renderWithLoggedInUser(props, callback) {\n\n    let router = useRouter()\n\n    // if logged in\n    if (props.loggedIn !== false) {\n        // validate permissions\n        let source = props.loggedInUserInfo\n        if (source) {\n            // check temp password\n            if (!router.asPath.startsWith(\"/profile\")\n                && source.account && source.account.isTempPassword) {\n                if (typeof window != \"undefined\") {\n                    window.location.href = \"/profile\"\n                }\n\n                return callback(props)\n            }\n\n\n        }\n\n        return callback(props) || null\n    }\n\n    // if not\n    else {\n\n\n\n        // do hard redirect to /login\n        if (typeof window != \"undefined\") {\n            window.location.href = \"/login?url=\" + router.asPath\n        }\n    }\n\n    return null\n}\n\n/**\n * \n */\nexport async function doLogout() {\n    return await fetch(\"/backend/core/account/v1/logout\", {\n        method: \"PUT\"\n    })\n}\n\n\nfunction comparePath(input, permission) {\n    if (permission.startsWith(\"=\")) {\n        if (input === permission.substr(1)) {\n            return true\n        }\n    } else if (input.startsWith(permission)) {\n        return true\n    }\n    return false\n}\n\nexport function acceptedScreenPath(userInfo, path) {\n    if (!userInfo) {\n        return false\n    }\n    if (path == \"/\" || path == \"/profile\") {\n        return true\n    }\n    let screens = userInfo.screens\n    let userRoles = userInfo.userRoles\n    let accepted = false\n    if (screens) {\n        for (let i = 0; i < screens.length; i++) {\n            if (screens[i].indexOf(\":departmentCode\") >= 0) {\n                for (let j = 0; userRoles && j < userRoles.length; j++) {\n                    let normalizedPath = screens[i].replace(\":departmentCode\", userRoles[j].departmentCode)\n                    if (comparePath(path, normalizedPath)) {\n                        accepted = true\n                        break\n                    }\n                }\n            } else {\n                if (comparePath(path, screens[i])) {\n                    accepted = true\n                    break\n                }\n            }\n\n\n        }\n    }\n    return accepted\n}\n\n"]},"metadata":{},"sourceType":"module"}