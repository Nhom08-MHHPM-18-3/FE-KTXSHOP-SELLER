{"ast":null,"code":"/*\r\nThis function return a session string by parsing cookie value of incoming request.\r\n */\nimport { useRouter } from \"next/router\";\nimport { APIStatus } from \"./common\";\nexport function getSessionToken(ctx, cookieName) {\n  cookieName = cookieName || \"session_token\";\n  let sessionStr = ctx.req && ctx.req.headers.cookie;\n  let session = undefined;\n\n  if (sessionStr) {\n    sessionStr.split(\";\").forEach(cookie => {\n      let i = cookie.indexOf(\"=\");\n      let name = cookie.substr(0, i).trim();\n      let value = cookie.substr(i + 1).trim();\n\n      if (name == cookieName) {\n        session = value;\n        return false;\n      }\n    });\n  }\n\n  return session;\n}\n\nasync function getLoggedUserInfo(ctx) {\n  let session = getSessionToken(ctx); // if there is not cookie with \"session_token\" name\n\n  let res = ctx.res;\n\n  if (!session || session === \"deleted\") {\n    session = getSessionToken(ctx, \"remember_me\");\n\n    if (!session || session === \"deleted\") {\n      res.setHeader(\"location\", \"/login?url=\" + escape(ctx.req.url));\n      res.statusCode = 302;\n      res.end();\n      return {\n        props: {\n          loggedIn: false\n        }\n      };\n    }\n\n    res.setHeader(\"set-cookie\", `session_token=${session}; Path=/; HttpOnly`);\n  } // if there is value\n\n\n  let req = {\n    method: \"GET\",\n    headers: {\n      \"Authorization\": `Bearer ${session}`,\n      \"User-Agent\": ctx.req.headers['user-agent'],\n      'X-Forwarded-For': ctx.req.headers['x-forwarded-for']\n    }\n  };\n  let url = process.env.API_HOST + \"/core/account/v1/me?getPermissions=true\";\n  return await fetch(url, req);\n}\n/**\r\n * This function is used by injecting to getServerSideProps of pages.\r\n * @param ctx\r\n * @param callback\r\n * @returns {Promise<*|{props: {loggedIn: boolean}}>}\r\n */\n\n\nexport async function doWithLoggedInUser(ctx, callback) {\n  // let result = await getLoggedUserInfo(ctx)\n  // let userInfo = await result.json()\n  // // must get user info successful before do anything else\n  // // console.log(userInfo)\n  // if (userInfo.status !== APIStatus.OK) {\n  //     return { props: { loggedIn: false } }\n  // }\n  // // check temp password\n  // let source = userInfo.data[0]\n  // let account = source.account\n  // if (!ctx.req.url.startsWith('/profile') && account.isTempPassword) {\n  //     if (typeof window === \"undefined\") {\n  //         let res = ctx.res\n  //         res.setHeader(\"location\", \"/profile\");\n  //         res.statusCode = 302;\n  //         res.end();\n  //     }\n  //     return { props: { loggedIn: true, loggedInUserInfo: source } }\n  // }\n  let result = callback(ctx); // // wait for page promise\n\n  if (result && result instanceof Promise) {\n    result = await result;\n  } // // set loggedIn = true if is is undefined\n\n\n  result = result || {};\n  result.props = result.props || {}; // result.props.loggedInUserInfo = userInfo.data[0]\n  // if (typeof result.props.loggedIn == \"undefined\") {\n\n  result.props.loggedIn = true; // }\n\n  return result;\n}\n/**\r\n * This function is used by injecting to render function of pages.\r\n * @param props\r\n * @param callback\r\n * @returns {null|*}\r\n */\n\nexport function renderWithLoggedInUser(props, callback) {\n  let router = useRouter(); // if logged in\n\n  if (props.loggedIn !== false) {\n    // validate permissions\n    let source = props.loggedInUserInfo;\n\n    if (source) {\n      // check temp password\n      if (!router.asPath.startsWith(\"/profile\") && source.account && source.account.isTempPassword) {\n        if (false) {\n          window.location.href = \"/profile\";\n        }\n\n        return callback(props);\n      }\n    }\n\n    return callback(props) || null;\n  } // if not\n  else {\n      // do hard redirect to /login\n      if (false) {\n        window.location.href = \"/login?url=\" + router.asPath;\n      }\n    }\n\n  return null;\n}\n/**\r\n * \r\n */\n\nexport async function doLogout() {\n  return await fetch(\"/backend/core/account/v1/logout\", {\n    method: \"PUT\"\n  });\n}\n\nfunction comparePath(input, permission) {\n  if (permission.startsWith(\"=\")) {\n    if (input === permission.substr(1)) {\n      return true;\n    }\n  } else if (input.startsWith(permission)) {\n    return true;\n  }\n\n  return false;\n}\n\nexport function acceptedScreenPath(userInfo, path) {\n  if (!userInfo) {\n    return false;\n  }\n\n  if (path == \"/\" || path == \"/profile\") {\n    return true;\n  }\n\n  let screens = userInfo.screens;\n  let userRoles = userInfo.userRoles;\n  let accepted = false;\n\n  if (screens) {\n    for (let i = 0; i < screens.length; i++) {\n      if (screens[i].indexOf(\":departmentCode\") >= 0) {\n        for (let j = 0; userRoles && j < userRoles.length; j++) {\n          let normalizedPath = screens[i].replace(\":departmentCode\", userRoles[j].departmentCode);\n\n          if (comparePath(path, normalizedPath)) {\n            accepted = true;\n            break;\n          }\n        }\n      } else {\n        if (comparePath(path, screens[i])) {\n          accepted = true;\n          break;\n        }\n      }\n    }\n  }\n\n  return accepted;\n}","map":{"version":3,"sources":["D:/Learning/Learning/HKI_NamTu/MoHinhHoaPhanMem/KTXSHOP/Source/FE-KTXSHOP-SELLER/lib/login.js"],"names":["useRouter","APIStatus","getSessionToken","ctx","cookieName","sessionStr","req","headers","cookie","session","undefined","split","forEach","i","indexOf","name","substr","trim","value","getLoggedUserInfo","res","setHeader","escape","url","statusCode","end","props","loggedIn","method","process","env","API_HOST","fetch","doWithLoggedInUser","callback","result","Promise","renderWithLoggedInUser","router","source","loggedInUserInfo","asPath","startsWith","account","isTempPassword","window","location","href","doLogout","comparePath","input","permission","acceptedScreenPath","userInfo","path","screens","userRoles","accepted","length","j","normalizedPath","replace","departmentCode"],"mappings":"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","sourcesContent":["/*\r\nThis function return a session string by parsing cookie value of incoming request.\r\n */\r\nimport { useRouter } from \"next/router\";\r\nimport { APIStatus } from \"./common\";\r\n\r\nexport function getSessionToken(ctx, cookieName) {\r\n    cookieName = cookieName || \"session_token\"\r\n    let sessionStr = ctx.req && ctx.req.headers.cookie\r\n    let session = undefined\r\n    if (sessionStr) {\r\n        sessionStr.split(\";\").forEach((cookie) => {\r\n            let i = cookie.indexOf(\"=\")\r\n            let name = cookie.substr(0, i).trim()\r\n            let value = cookie.substr(i + 1).trim()\r\n            if (name == cookieName) {\r\n                session = value\r\n                return false\r\n            }\r\n        })\r\n    }\r\n    return session\r\n}\r\n\r\nasync function getLoggedUserInfo(ctx) {\r\n    let session = getSessionToken(ctx)\r\n\r\n    // if there is not cookie with \"session_token\" name\r\n    let res = ctx.res\r\n    if (!session || session === \"deleted\") {\r\n        session = getSessionToken(ctx, \"remember_me\")\r\n        if (!session || session === \"deleted\") {\r\n            res.setHeader(\"location\", \"/login?url=\" + escape(ctx.req.url));\r\n            res.statusCode = 302;\r\n            res.end();\r\n            return { props: { loggedIn: false } }\r\n        }\r\n\r\n        res.setHeader(\"set-cookie\", `session_token=${session}; Path=/; HttpOnly`)\r\n    }\r\n\r\n    // if there is value\r\n    let req = {\r\n        method: \"GET\",\r\n        headers: {\r\n            \"Authorization\": `Bearer ${session}`,\r\n            \"User-Agent\": ctx.req.headers['user-agent'],\r\n            'X-Forwarded-For': ctx.req.headers['x-forwarded-for']\r\n        }\r\n    }\r\n    let url = process.env.API_HOST + \"/core/account/v1/me?getPermissions=true\"\r\n    return await fetch(url, req)\r\n}\r\n\r\n/**\r\n * This function is used by injecting to getServerSideProps of pages.\r\n * @param ctx\r\n * @param callback\r\n * @returns {Promise<*|{props: {loggedIn: boolean}}>}\r\n */\r\nexport async function doWithLoggedInUser(ctx, callback) {\r\n    // let result = await getLoggedUserInfo(ctx)\r\n    // let userInfo = await result.json()\r\n\r\n    // // must get user info successful before do anything else\r\n    // // console.log(userInfo)\r\n    // if (userInfo.status !== APIStatus.OK) {\r\n    //     return { props: { loggedIn: false } }\r\n    // }\r\n\r\n    // // check temp password\r\n    // let source = userInfo.data[0]\r\n    // let account = source.account\r\n\r\n    // if (!ctx.req.url.startsWith('/profile') && account.isTempPassword) {\r\n    //     if (typeof window === \"undefined\") {\r\n    //         let res = ctx.res\r\n    //         res.setHeader(\"location\", \"/profile\");\r\n    //         res.statusCode = 302;\r\n    //         res.end();\r\n    //     }\r\n    //     return { props: { loggedIn: true, loggedInUserInfo: source } }\r\n    // }\r\n\r\n    let result = callback(ctx)\r\n    // // wait for page promise\r\n    if (result && result instanceof Promise) {\r\n        result = await result\r\n    }\r\n\r\n    // // set loggedIn = true if is is undefined\r\n    result = result || {}\r\n    result.props = result.props || {}\r\n    // result.props.loggedInUserInfo = userInfo.data[0]\r\n    // if (typeof result.props.loggedIn == \"undefined\") {\r\n    result.props.loggedIn = true\r\n    // }\r\n    return result\r\n}\r\n\r\n/**\r\n * This function is used by injecting to render function of pages.\r\n * @param props\r\n * @param callback\r\n * @returns {null|*}\r\n */\r\nexport function renderWithLoggedInUser(props, callback) {\r\n\r\n    let router = useRouter()\r\n\r\n    // if logged in\r\n    if (props.loggedIn !== false) {\r\n        // validate permissions\r\n        let source = props.loggedInUserInfo\r\n        if (source) {\r\n            // check temp password\r\n            if (!router.asPath.startsWith(\"/profile\")\r\n                && source.account && source.account.isTempPassword) {\r\n                if (typeof window != \"undefined\") {\r\n                    window.location.href = \"/profile\"\r\n                }\r\n\r\n                return callback(props)\r\n            }\r\n\r\n\r\n        }\r\n\r\n        return callback(props) || null\r\n    }\r\n\r\n    // if not\r\n    else {\r\n\r\n\r\n\r\n        // do hard redirect to /login\r\n        if (typeof window != \"undefined\") {\r\n            window.location.href = \"/login?url=\" + router.asPath\r\n        }\r\n    }\r\n\r\n    return null\r\n}\r\n\r\n/**\r\n * \r\n */\r\nexport async function doLogout() {\r\n    return await fetch(\"/backend/core/account/v1/logout\", {\r\n        method: \"PUT\"\r\n    })\r\n}\r\n\r\n\r\nfunction comparePath(input, permission) {\r\n    if (permission.startsWith(\"=\")) {\r\n        if (input === permission.substr(1)) {\r\n            return true\r\n        }\r\n    } else if (input.startsWith(permission)) {\r\n        return true\r\n    }\r\n    return false\r\n}\r\n\r\nexport function acceptedScreenPath(userInfo, path) {\r\n    if (!userInfo) {\r\n        return false\r\n    }\r\n    if (path == \"/\" || path == \"/profile\") {\r\n        return true\r\n    }\r\n    let screens = userInfo.screens\r\n    let userRoles = userInfo.userRoles\r\n    let accepted = false\r\n    if (screens) {\r\n        for (let i = 0; i < screens.length; i++) {\r\n            if (screens[i].indexOf(\":departmentCode\") >= 0) {\r\n                for (let j = 0; userRoles && j < userRoles.length; j++) {\r\n                    let normalizedPath = screens[i].replace(\":departmentCode\", userRoles[j].departmentCode)\r\n                    if (comparePath(path, normalizedPath)) {\r\n                        accepted = true\r\n                        break\r\n                    }\r\n                }\r\n            } else {\r\n                if (comparePath(path, screens[i])) {\r\n                    accepted = true\r\n                    break\r\n                }\r\n            }\r\n\r\n\r\n        }\r\n    }\r\n    return accepted\r\n}\r\n\r\n"]},"metadata":{},"sourceType":"module"}