{"ast":null,"code":"import _regeneratorRuntime from \"D:/Learning/Learning/HKI_NamTu/MoHinhHoaPhanMem/KTXSHOP/Source/FE-KTXSHOP-SELLER/node_modules/next/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"D:/Learning/Learning/HKI_NamTu/MoHinhHoaPhanMem/KTXSHOP/Source/FE-KTXSHOP-SELLER/node_modules/next/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\nvar _s = $RefreshSig$();\n\n/*\r\nThis function return a session string by parsing cookie value of incoming request.\r\n */\nimport { useRouter } from \"next/router\";\nimport { APIStatus } from \"./common\";\nimport { useContext } from \"react\";\nimport UserContext from \"../component/my-context/my-context\";\nexport function getSessionToken(ctx, cookieName) {\n  cookieName = cookieName || \"session_token\";\n  var sessionStr = ctx.req && ctx.req.headers.cookie;\n  var session = undefined;\n\n  if (sessionStr) {\n    sessionStr.split(\";\").forEach(function (cookie) {\n      var i = cookie.indexOf(\"=\");\n      var name = cookie.substr(0, i).trim();\n      var value = cookie.substr(i + 1).trim();\n\n      if (name == cookieName) {\n        session = value;\n        return false;\n      }\n    });\n  }\n\n  return session;\n}\n\nfunction getLoggedUserInfo(_x) {\n  return _getLoggedUserInfo.apply(this, arguments);\n}\n/**\r\n * This function is used by injecting to getServerSideProps of pages.\r\n * @param ctx\r\n * @param callback\r\n * @returns {Promise<*|{props: {loggedIn: boolean}}>}\r\n */\n\n\nfunction _getLoggedUserInfo() {\n  _getLoggedUserInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(ctx) {\n    var session, res, req, url;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            session = getSessionToken(ctx); // if there is not cookie with \"session_token\" name\n\n            res = ctx.res;\n\n            if (!(!session || session === \"deleted\")) {\n              _context.next = 10;\n              break;\n            }\n\n            session = getSessionToken(ctx, \"remember_me\");\n\n            if (!(!session || session === \"deleted\")) {\n              _context.next = 9;\n              break;\n            }\n\n            res.setHeader(\"location\", \"/login?url=\" + escape(ctx.req.url));\n            res.statusCode = 302;\n            res.end();\n            return _context.abrupt(\"return\", {\n              props: {\n                loggedIn: false\n              }\n            });\n\n          case 9:\n            res.setHeader(\"set-cookie\", \"session_token=\".concat(session, \"; Path=/; HttpOnly\"));\n\n          case 10:\n            // if there is value\n            req = {\n              method: \"GET\",\n              headers: {\n                Authorization: \"Bearer \".concat(session),\n                \"User-Agent\": ctx.req.headers[\"user-agent\"],\n                \"X-Forwarded-For\": ctx.req.headers[\"x-forwarded-for\"]\n              }\n            };\n            url = process.env.API_HOST + \"/core/account/v1/me?getPermissions=true\";\n            _context.next = 14;\n            return fetch(url, req);\n\n          case 14:\n            return _context.abrupt(\"return\", _context.sent);\n\n          case 15:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _getLoggedUserInfo.apply(this, arguments);\n}\n\nexport function doWithLoggedInUser(_x2, _x3) {\n  return _doWithLoggedInUser.apply(this, arguments);\n}\n/**\r\n * This function is used by injecting to render function of pages.\r\n * @param props\r\n * @param callback\r\n * @returns {null|*}\r\n */\n\nfunction _doWithLoggedInUser() {\n  _doWithLoggedInUser = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(ctx, callback) {\n    var result;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            // let result = await getLoggedUserInfo(ctx)\n            // let userInfo = await result.json()\n            // // must get user info successful before do anything else\n            // // console.log(userInfo)\n            // if (userInfo.status !== APIStatus.OK) {\n            //     return { props: { loggedIn: false } }\n            // }\n            // // check temp password\n            // let source = userInfo.data[0]\n            // let account = source.account\n            // if (!ctx.req.url.startsWith('/profile') && account.isTempPassword) {\n            //     if (typeof window === \"undefined\") {\n            //         let res = ctx.res\n            //         res.setHeader(\"location\", \"/profile\");\n            //         res.statusCode = 302;\n            //         res.end();\n            //     }\n            //     return { props: { loggedIn: true, loggedInUserInfo: source } }\n            // }\n            result = callback(ctx); // // wait for page promise\n\n            if (!(result && result instanceof Promise)) {\n              _context2.next = 5;\n              break;\n            }\n\n            _context2.next = 4;\n            return result;\n\n          case 4:\n            result = _context2.sent;\n\n          case 5:\n            // // set loggedIn = true if is is undefined\n            result = result || {};\n            result.props = result.props || {}; // result.props.loggedInUserInfo = userInfo.data[0]\n            // if (typeof result.props.loggedIn == \"undefined\") {\n\n            result.props.loggedIn = true; // }\n\n            return _context2.abrupt(\"return\", result);\n\n          case 9:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _doWithLoggedInUser.apply(this, arguments);\n}\n\nexport function renderWithLoggedInUser(props, callback) {\n  _s();\n\n  var router = useRouter();\n  var login = useContext(UserContext);\n  console.log(login); // if logged in\n\n  if (props.loggedIn !== false) {\n    // validate permissions\n    var source = props.loggedInUserInfo;\n    console.log(props.loggedIn);\n\n    if (source) {\n      // check temp password\n      if (!router.asPath.startsWith(\"/profile\") && source.account && source.account.isTempPassword) {\n        if (true) {\n          window.location.href = \"/profile\";\n        }\n\n        return callback(props);\n      }\n    }\n\n    return callback(props) || null;\n  } // if not\n  else {\n      // do hard redirect to /login\n      if (true) {\n        window.location.href = \"/login\";\n      }\n    }\n\n  return null;\n}\n/**\r\n *\r\n */\n\n_s(renderWithLoggedInUser, \"dkvO75eNi1xqpYak5IchZZpnFCA=\", false, function () {\n  return [useRouter];\n});\n\nexport function doLogout() {\n  return _doLogout.apply(this, arguments);\n}\n\nfunction _doLogout() {\n  _doLogout = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.next = 2;\n            return fetch(\"/backend/core/account/v1/logout\", {\n              method: \"PUT\"\n            });\n\n          case 2:\n            return _context3.abrupt(\"return\", _context3.sent);\n\n          case 3:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _doLogout.apply(this, arguments);\n}\n\nfunction comparePath(input, permission) {\n  if (permission.startsWith(\"=\")) {\n    if (input === permission.substr(1)) {\n      return true;\n    }\n  } else if (input.startsWith(permission)) {\n    return true;\n  }\n\n  return false;\n}\n\nexport function acceptedScreenPath(userInfo, path) {\n  if (!userInfo) {\n    return false;\n  }\n\n  if (path == \"/\" || path == \"/profile\") {\n    return true;\n  }\n\n  var screens = userInfo.screens;\n  var userRoles = userInfo.userRoles;\n  var accepted = false;\n\n  if (screens) {\n    for (var i = 0; i < screens.length; i++) {\n      if (screens[i].indexOf(\":departmentCode\") >= 0) {\n        for (var j = 0; userRoles && j < userRoles.length; j++) {\n          var normalizedPath = screens[i].replace(\":departmentCode\", userRoles[j].departmentCode);\n\n          if (comparePath(path, normalizedPath)) {\n            accepted = true;\n            break;\n          }\n        }\n      } else {\n        if (comparePath(path, screens[i])) {\n          accepted = true;\n          break;\n        }\n      }\n    }\n  }\n\n  return accepted;\n}","map":{"version":3,"sources":["D:/Learning/Learning/HKI_NamTu/MoHinhHoaPhanMem/KTXSHOP/Source/FE-KTXSHOP-SELLER/lib/login.js"],"names":["useRouter","APIStatus","useContext","UserContext","getSessionToken","ctx","cookieName","sessionStr","req","headers","cookie","session","undefined","split","forEach","i","indexOf","name","substr","trim","value","getLoggedUserInfo","res","setHeader","escape","url","statusCode","end","props","loggedIn","method","Authorization","process","env","API_HOST","fetch","doWithLoggedInUser","callback","result","Promise","renderWithLoggedInUser","router","login","console","log","source","loggedInUserInfo","asPath","startsWith","account","isTempPassword","window","location","href","doLogout","comparePath","input","permission","acceptedScreenPath","userInfo","path","screens","userRoles","accepted","length","j","normalizedPath","replace","departmentCode"],"mappings":";;;;;AAAA;AACA;AACA;AACA,SAASA,SAAT,QAA0B,aAA1B;AACA,SAASC,SAAT,QAA0B,UAA1B;AACA,SAASC,UAAT,QAA2B,OAA3B;AACA,OAAOC,WAAP,MAAwB,oCAAxB;AAEA,OAAO,SAASC,eAAT,CAAyBC,GAAzB,EAA8BC,UAA9B,EAA0C;AAC/CA,EAAAA,UAAU,GAAGA,UAAU,IAAI,eAA3B;AACA,MAAIC,UAAU,GAAGF,GAAG,CAACG,GAAJ,IAAWH,GAAG,CAACG,GAAJ,CAAQC,OAAR,CAAgBC,MAA5C;AACA,MAAIC,OAAO,GAAGC,SAAd;;AACA,MAAIL,UAAJ,EAAgB;AACdA,IAAAA,UAAU,CAACM,KAAX,CAAiB,GAAjB,EAAsBC,OAAtB,CAA8B,UAACJ,MAAD,EAAY;AACxC,UAAIK,CAAC,GAAGL,MAAM,CAACM,OAAP,CAAe,GAAf,CAAR;AACA,UAAIC,IAAI,GAAGP,MAAM,CAACQ,MAAP,CAAc,CAAd,EAAiBH,CAAjB,EAAoBI,IAApB,EAAX;AACA,UAAIC,KAAK,GAAGV,MAAM,CAACQ,MAAP,CAAcH,CAAC,GAAG,CAAlB,EAAqBI,IAArB,EAAZ;;AACA,UAAIF,IAAI,IAAIX,UAAZ,EAAwB;AACtBK,QAAAA,OAAO,GAAGS,KAAV;AACA,eAAO,KAAP;AACD;AACF,KARD;AASD;;AACD,SAAOT,OAAP;AACD;;SAEcU,iB;;;AA8Bf;AACA;AACA;AACA;AACA;AACA;;;;gFAnCA,iBAAiChB,GAAjC;AAAA;AAAA;AAAA;AAAA;AAAA;AACMM,YAAAA,OADN,GACgBP,eAAe,CAACC,GAAD,CAD/B,EAGE;;AACIiB,YAAAA,GAJN,GAIYjB,GAAG,CAACiB,GAJhB;;AAAA,kBAKM,CAACX,OAAD,IAAYA,OAAO,KAAK,SAL9B;AAAA;AAAA;AAAA;;AAMIA,YAAAA,OAAO,GAAGP,eAAe,CAACC,GAAD,EAAM,aAAN,CAAzB;;AANJ,kBAOQ,CAACM,OAAD,IAAYA,OAAO,KAAK,SAPhC;AAAA;AAAA;AAAA;;AAQMW,YAAAA,GAAG,CAACC,SAAJ,CAAc,UAAd,EAA0B,gBAAgBC,MAAM,CAACnB,GAAG,CAACG,GAAJ,CAAQiB,GAAT,CAAhD;AACAH,YAAAA,GAAG,CAACI,UAAJ,GAAiB,GAAjB;AACAJ,YAAAA,GAAG,CAACK,GAAJ;AAVN,6CAWa;AAAEC,cAAAA,KAAK,EAAE;AAAEC,gBAAAA,QAAQ,EAAE;AAAZ;AAAT,aAXb;;AAAA;AAcIP,YAAAA,GAAG,CAACC,SAAJ,CAAc,YAAd,0BAA6CZ,OAA7C;;AAdJ;AAiBE;AACIH,YAAAA,GAlBN,GAkBY;AACRsB,cAAAA,MAAM,EAAE,KADA;AAERrB,cAAAA,OAAO,EAAE;AACPsB,gBAAAA,aAAa,mBAAYpB,OAAZ,CADN;AAEP,8BAAcN,GAAG,CAACG,GAAJ,CAAQC,OAAR,CAAgB,YAAhB,CAFP;AAGP,mCAAmBJ,GAAG,CAACG,GAAJ,CAAQC,OAAR,CAAgB,iBAAhB;AAHZ;AAFD,aAlBZ;AA0BMgB,YAAAA,GA1BN,GA0BYO,OAAO,CAACC,GAAR,CAAYC,QAAZ,GAAuB,yCA1BnC;AAAA;AAAA,mBA2BeC,KAAK,CAACV,GAAD,EAAMjB,GAAN,CA3BpB;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;AAoCA,gBAAsB4B,kBAAtB;AAAA;AAAA;AAwCA;AACA;AACA;AACA;AACA;AACA;;;iFA7CO,kBAAkC/B,GAAlC,EAAuCgC,QAAvC;AAAA;AAAA;AAAA;AAAA;AAAA;AACL;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEIC,YAAAA,MAxBC,GAwBQD,QAAQ,CAAChC,GAAD,CAxBhB,EAyBL;;AAzBK,kBA0BDiC,MAAM,IAAIA,MAAM,YAAYC,OA1B3B;AAAA;AAAA;AAAA;;AAAA;AAAA,mBA2BYD,MA3BZ;;AAAA;AA2BHA,YAAAA,MA3BG;;AAAA;AA8BL;AACAA,YAAAA,MAAM,GAAGA,MAAM,IAAI,EAAnB;AACAA,YAAAA,MAAM,CAACV,KAAP,GAAeU,MAAM,CAACV,KAAP,IAAgB,EAA/B,CAhCK,CAiCL;AACA;;AACAU,YAAAA,MAAM,CAACV,KAAP,CAAaC,QAAb,GAAwB,IAAxB,CAnCK,CAoCL;;AApCK,8CAqCES,MArCF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;AA8CP,OAAO,SAASE,sBAAT,CAAgCZ,KAAhC,EAAuCS,QAAvC,EAAiD;AAAA;;AACtD,MAAII,MAAM,GAAGzC,SAAS,EAAtB;AAEA,MAAM0C,KAAK,GAAGxC,UAAU,CAACC,WAAD,CAAxB;AACAwC,EAAAA,OAAO,CAACC,GAAR,CAAYF,KAAZ,EAJsD,CAMtD;;AACA,MAAId,KAAK,CAACC,QAAN,KAAmB,KAAvB,EAA8B;AAC5B;AACA,QAAIgB,MAAM,GAAGjB,KAAK,CAACkB,gBAAnB;AAEAH,IAAAA,OAAO,CAACC,GAAR,CAAYhB,KAAK,CAACC,QAAlB;;AAEA,QAAIgB,MAAJ,EAAY;AACV;AACA,UACE,CAACJ,MAAM,CAACM,MAAP,CAAcC,UAAd,CAAyB,UAAzB,CAAD,IACAH,MAAM,CAACI,OADP,IAEAJ,MAAM,CAACI,OAAP,CAAeC,cAHjB,EAIE;AACA,kBAAkC;AAChCC,UAAAA,MAAM,CAACC,QAAP,CAAgBC,IAAhB,GAAuB,UAAvB;AACD;;AAED,eAAOhB,QAAQ,CAACT,KAAD,CAAf;AACD;AACF;;AAED,WAAOS,QAAQ,CAACT,KAAD,CAAR,IAAmB,IAA1B;AACD,GAtBD,CAwBA;AAxBA,OAyBK;AACH;AACA,gBAAkC;AAChCuB,QAAAA,MAAM,CAACC,QAAP,CAAgBC,IAAhB,GAAuB,QAAvB;AACD;AACF;;AAED,SAAO,IAAP;AACD;AAED;AACA;AACA;;GA5CgBb,sB;UACDxC,S;;;AA4Cf,gBAAsBsD,QAAtB;AAAA;AAAA;;;uEAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBACQnB,KAAK,CAAC,iCAAD,EAAoC;AACpDL,cAAAA,MAAM,EAAE;AAD4C,aAApC,CADb;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;AAMP,SAASyB,WAAT,CAAqBC,KAArB,EAA4BC,UAA5B,EAAwC;AACtC,MAAIA,UAAU,CAACT,UAAX,CAAsB,GAAtB,CAAJ,EAAgC;AAC9B,QAAIQ,KAAK,KAAKC,UAAU,CAACvC,MAAX,CAAkB,CAAlB,CAAd,EAAoC;AAClC,aAAO,IAAP;AACD;AACF,GAJD,MAIO,IAAIsC,KAAK,CAACR,UAAN,CAAiBS,UAAjB,CAAJ,EAAkC;AACvC,WAAO,IAAP;AACD;;AACD,SAAO,KAAP;AACD;;AAED,OAAO,SAASC,kBAAT,CAA4BC,QAA5B,EAAsCC,IAAtC,EAA4C;AACjD,MAAI,CAACD,QAAL,EAAe;AACb,WAAO,KAAP;AACD;;AACD,MAAIC,IAAI,IAAI,GAAR,IAAeA,IAAI,IAAI,UAA3B,EAAuC;AACrC,WAAO,IAAP;AACD;;AACD,MAAIC,OAAO,GAAGF,QAAQ,CAACE,OAAvB;AACA,MAAIC,SAAS,GAAGH,QAAQ,CAACG,SAAzB;AACA,MAAIC,QAAQ,GAAG,KAAf;;AACA,MAAIF,OAAJ,EAAa;AACX,SAAK,IAAI9C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG8C,OAAO,CAACG,MAA5B,EAAoCjD,CAAC,EAArC,EAAyC;AACvC,UAAI8C,OAAO,CAAC9C,CAAD,CAAP,CAAWC,OAAX,CAAmB,iBAAnB,KAAyC,CAA7C,EAAgD;AAC9C,aAAK,IAAIiD,CAAC,GAAG,CAAb,EAAgBH,SAAS,IAAIG,CAAC,GAAGH,SAAS,CAACE,MAA3C,EAAmDC,CAAC,EAApD,EAAwD;AACtD,cAAIC,cAAc,GAAGL,OAAO,CAAC9C,CAAD,CAAP,CAAWoD,OAAX,CACnB,iBADmB,EAEnBL,SAAS,CAACG,CAAD,CAAT,CAAaG,cAFM,CAArB;;AAIA,cAAIb,WAAW,CAACK,IAAD,EAAOM,cAAP,CAAf,EAAuC;AACrCH,YAAAA,QAAQ,GAAG,IAAX;AACA;AACD;AACF;AACF,OAXD,MAWO;AACL,YAAIR,WAAW,CAACK,IAAD,EAAOC,OAAO,CAAC9C,CAAD,CAAd,CAAf,EAAmC;AACjCgD,UAAAA,QAAQ,GAAG,IAAX;AACA;AACD;AACF;AACF;AACF;;AACD,SAAOA,QAAP;AACD","sourcesContent":["/*\r\nThis function return a session string by parsing cookie value of incoming request.\r\n */\r\nimport { useRouter } from \"next/router\";\r\nimport { APIStatus } from \"./common\";\r\nimport { useContext } from \"react\";\r\nimport UserContext from \"../component/my-context/my-context\";\r\n\r\nexport function getSessionToken(ctx, cookieName) {\r\n  cookieName = cookieName || \"session_token\";\r\n  let sessionStr = ctx.req && ctx.req.headers.cookie;\r\n  let session = undefined;\r\n  if (sessionStr) {\r\n    sessionStr.split(\";\").forEach((cookie) => {\r\n      let i = cookie.indexOf(\"=\");\r\n      let name = cookie.substr(0, i).trim();\r\n      let value = cookie.substr(i + 1).trim();\r\n      if (name == cookieName) {\r\n        session = value;\r\n        return false;\r\n      }\r\n    });\r\n  }\r\n  return session;\r\n}\r\n\r\nasync function getLoggedUserInfo(ctx) {\r\n  let session = getSessionToken(ctx);\r\n\r\n  // if there is not cookie with \"session_token\" name\r\n  let res = ctx.res;\r\n  if (!session || session === \"deleted\") {\r\n    session = getSessionToken(ctx, \"remember_me\");\r\n    if (!session || session === \"deleted\") {\r\n      res.setHeader(\"location\", \"/login?url=\" + escape(ctx.req.url));\r\n      res.statusCode = 302;\r\n      res.end();\r\n      return { props: { loggedIn: false } };\r\n    }\r\n\r\n    res.setHeader(\"set-cookie\", `session_token=${session}; Path=/; HttpOnly`);\r\n  }\r\n\r\n  // if there is value\r\n  let req = {\r\n    method: \"GET\",\r\n    headers: {\r\n      Authorization: `Bearer ${session}`,\r\n      \"User-Agent\": ctx.req.headers[\"user-agent\"],\r\n      \"X-Forwarded-For\": ctx.req.headers[\"x-forwarded-for\"],\r\n    },\r\n  };\r\n  let url = process.env.API_HOST + \"/core/account/v1/me?getPermissions=true\";\r\n  return await fetch(url, req);\r\n}\r\n\r\n/**\r\n * This function is used by injecting to getServerSideProps of pages.\r\n * @param ctx\r\n * @param callback\r\n * @returns {Promise<*|{props: {loggedIn: boolean}}>}\r\n */\r\nexport async function doWithLoggedInUser(ctx, callback) {\r\n  // let result = await getLoggedUserInfo(ctx)\r\n  // let userInfo = await result.json()\r\n\r\n  // // must get user info successful before do anything else\r\n  // // console.log(userInfo)\r\n  // if (userInfo.status !== APIStatus.OK) {\r\n  //     return { props: { loggedIn: false } }\r\n  // }\r\n\r\n  // // check temp password\r\n  // let source = userInfo.data[0]\r\n  // let account = source.account\r\n\r\n  // if (!ctx.req.url.startsWith('/profile') && account.isTempPassword) {\r\n  //     if (typeof window === \"undefined\") {\r\n  //         let res = ctx.res\r\n  //         res.setHeader(\"location\", \"/profile\");\r\n  //         res.statusCode = 302;\r\n  //         res.end();\r\n  //     }\r\n  //     return { props: { loggedIn: true, loggedInUserInfo: source } }\r\n  // }\r\n\r\n  let result = callback(ctx);\r\n  // // wait for page promise\r\n  if (result && result instanceof Promise) {\r\n    result = await result;\r\n  }\r\n\r\n  // // set loggedIn = true if is is undefined\r\n  result = result || {};\r\n  result.props = result.props || {};\r\n  // result.props.loggedInUserInfo = userInfo.data[0]\r\n  // if (typeof result.props.loggedIn == \"undefined\") {\r\n  result.props.loggedIn = true;\r\n  // }\r\n  return result;\r\n}\r\n\r\n/**\r\n * This function is used by injecting to render function of pages.\r\n * @param props\r\n * @param callback\r\n * @returns {null|*}\r\n */\r\nexport function renderWithLoggedInUser(props, callback) {\r\n  let router = useRouter();\r\n\r\n  const login = useContext(UserContext);\r\n  console.log(login);\r\n\r\n  // if logged in\r\n  if (props.loggedIn !== false) {\r\n    // validate permissions\r\n    let source = props.loggedInUserInfo;\r\n\r\n    console.log(props.loggedIn);\r\n\r\n    if (source) {\r\n      // check temp password\r\n      if (\r\n        !router.asPath.startsWith(\"/profile\") &&\r\n        source.account &&\r\n        source.account.isTempPassword\r\n      ) {\r\n        if (typeof window != \"undefined\") {\r\n          window.location.href = \"/profile\";\r\n        }\r\n\r\n        return callback(props);\r\n      }\r\n    }\r\n\r\n    return callback(props) || null;\r\n  }\r\n\r\n  // if not\r\n  else {\r\n    // do hard redirect to /login\r\n    if (typeof window != \"undefined\") {\r\n      window.location.href = \"/login\";\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\n/**\r\n *\r\n */\r\nexport async function doLogout() {\r\n  return await fetch(\"/backend/core/account/v1/logout\", {\r\n    method: \"PUT\",\r\n  });\r\n}\r\n\r\nfunction comparePath(input, permission) {\r\n  if (permission.startsWith(\"=\")) {\r\n    if (input === permission.substr(1)) {\r\n      return true;\r\n    }\r\n  } else if (input.startsWith(permission)) {\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function acceptedScreenPath(userInfo, path) {\r\n  if (!userInfo) {\r\n    return false;\r\n  }\r\n  if (path == \"/\" || path == \"/profile\") {\r\n    return true;\r\n  }\r\n  let screens = userInfo.screens;\r\n  let userRoles = userInfo.userRoles;\r\n  let accepted = false;\r\n  if (screens) {\r\n    for (let i = 0; i < screens.length; i++) {\r\n      if (screens[i].indexOf(\":departmentCode\") >= 0) {\r\n        for (let j = 0; userRoles && j < userRoles.length; j++) {\r\n          let normalizedPath = screens[i].replace(\r\n            \":departmentCode\",\r\n            userRoles[j].departmentCode\r\n          );\r\n          if (comparePath(path, normalizedPath)) {\r\n            accepted = true;\r\n            break;\r\n          }\r\n        }\r\n      } else {\r\n        if (comparePath(path, screens[i])) {\r\n          accepted = true;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return accepted;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}