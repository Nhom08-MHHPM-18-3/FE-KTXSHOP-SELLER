{"ast":null,"code":"/*\r\nThis function return a session string by parsing cookie value of incoming request.\r\n */\nimport { useRouter } from \"next/router\";\nimport { APIStatus } from \"./common\";\nexport function getSessionToken(ctx, cookieName) {\n  cookieName = cookieName || \"session_token\";\n  let sessionStr = ctx.req && ctx.req.headers.cookie;\n  let session = undefined;\n\n  if (sessionStr) {\n    sessionStr.split(\";\").forEach(cookie => {\n      let i = cookie.indexOf(\"=\");\n      let name = cookie.substr(0, i).trim();\n      let value = cookie.substr(i + 1).trim();\n\n      if (name == cookieName) {\n        session = value;\n        return false;\n      }\n    });\n  }\n\n  return session;\n}\n\nasync function getLoggedUserInfo(ctx) {\n  let session = getSessionToken(ctx); // if there is not cookie with \"session_token\" name\n\n  let res = ctx.res;\n\n  if (!session || session === \"deleted\") {\n    session = getSessionToken(ctx, \"remember_me\");\n\n    if (!session || session === \"deleted\") {\n      res.setHeader(\"location\", \"/login?url=\" + escape(ctx.req.url));\n      res.statusCode = 302;\n      res.end();\n      return {\n        props: {\n          loggedIn: false\n        }\n      };\n    }\n\n    res.setHeader(\"set-cookie\", `session_token=${session}; Path=/; HttpOnly`);\n  } // if there is value\n\n\n  let req = {\n    method: \"GET\",\n    headers: {\n      Authorization: `Bearer ${session}`,\n      \"User-Agent\": ctx.req.headers[\"user-agent\"],\n      \"X-Forwarded-For\": ctx.req.headers[\"x-forwarded-for\"]\n    }\n  };\n  let url = process.env.API_HOST + \"/core/account/v1/me?getPermissions=true\";\n  return await fetch(url, req);\n}\n/**\r\n * This function is used by injecting to getServerSideProps of pages.\r\n * @param ctx\r\n * @param callback\r\n * @returns {Promise<*|{props: {loggedIn: boolean}}>}\r\n */\n\n\nexport async function doWithLoggedInUser(ctx, callback) {\n  // let result = await getLoggedUserInfo(ctx)\n  // let userInfo = await result.json()\n  // // must get user info successful before do anything else\n  // // console.log(userInfo)\n  // if (userInfo.status !== APIStatus.OK) {\n  //     return { props: { loggedIn: false } }\n  // }\n  // // check temp password\n  // let source = userInfo.data[0]\n  // let account = source.account\n  // if (!ctx.req.url.startsWith('/profile') && account.isTempPassword) {\n  //     if (typeof window === \"undefined\") {\n  //         let res = ctx.res\n  //         res.setHeader(\"location\", \"/profile\");\n  //         res.statusCode = 302;\n  //         res.end();\n  //     }\n  //     return { props: { loggedIn: true, loggedInUserInfo: source } }\n  // }\n  let result = callback(ctx); // // wait for page promise\n\n  if (result && result instanceof Promise) {\n    result = await result;\n  } // // set loggedIn = true if is is undefined\n\n\n  result = result || {};\n  result.props = result.props || {}; // result.props.loggedInUserInfo = userInfo.data[0]\n  // if (typeof result.props.loggedIn == \"undefined\") {\n\n  result.props.loggedIn = true; // }\n\n  return result;\n}\n/**\r\n * This function is used by injecting to render function of pages.\r\n * @param props\r\n * @param callback\r\n * @returns {null|*}\r\n */\n\nexport function renderWithLoggedInUser(props, callback) {\n  let router = useRouter(); // if logged in\n\n  if (props.loggedIn !== false) {\n    // validate permissions\n    let source = props.loggedInUserInfo;\n\n    if (source) {\n      // check temp password\n      if (!router.asPath.startsWith(\"/profile\") && source.account && source.account.isTempPassword) {\n        if (false) {\n          window.location.href = \"/profile\";\n        }\n\n        return callback(props);\n      }\n    }\n\n    return callback(props) || null;\n  } // if not\n  else {\n      // do hard redirect to /login\n      if (false) {\n        window.location.href = \"/login?url=\" + router.asPath;\n      }\n    }\n\n  return null;\n}\n/**\r\n *\r\n */\n\nexport async function doLogout() {\n  return await fetch(\"/backend/core/account/v1/logout\", {\n    method: \"PUT\"\n  });\n}\n\nfunction comparePath(input, permission) {\n  if (permission.startsWith(\"=\")) {\n    if (input === permission.substr(1)) {\n      return true;\n    }\n  } else if (input.startsWith(permission)) {\n    return true;\n  }\n\n  return false;\n}\n\nexport function acceptedScreenPath(userInfo, path) {\n  if (!userInfo) {\n    return false;\n  }\n\n  if (path == \"/\" || path == \"/profile\") {\n    return true;\n  }\n\n  let screens = userInfo.screens;\n  let userRoles = userInfo.userRoles;\n  let accepted = false;\n\n  if (screens) {\n    for (let i = 0; i < screens.length; i++) {\n      if (screens[i].indexOf(\":departmentCode\") >= 0) {\n        for (let j = 0; userRoles && j < userRoles.length; j++) {\n          let normalizedPath = screens[i].replace(\":departmentCode\", userRoles[j].departmentCode);\n\n          if (comparePath(path, normalizedPath)) {\n            accepted = true;\n            break;\n          }\n        }\n      } else {\n        if (comparePath(path, screens[i])) {\n          accepted = true;\n          break;\n        }\n      }\n    }\n  }\n\n  return accepted;\n}","map":{"version":3,"sources":["D:/Learning/Learning/HKI_NamTu/MoHinhHoaPhanMem/KTXSHOP/Source/FE-KTXSHOP-SELLER/lib/login.js"],"names":["useRouter","APIStatus","getSessionToken","ctx","cookieName","sessionStr","req","headers","cookie","session","undefined","split","forEach","i","indexOf","name","substr","trim","value","getLoggedUserInfo","res","setHeader","escape","url","statusCode","end","props","loggedIn","method","Authorization","process","env","API_HOST","fetch","doWithLoggedInUser","callback","result","Promise","renderWithLoggedInUser","router","source","loggedInUserInfo","asPath","startsWith","account","isTempPassword","window","location","href","doLogout","comparePath","input","permission","acceptedScreenPath","userInfo","path","screens","userRoles","accepted","length","j","normalizedPath","replace","departmentCode"],"mappings":"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","sourcesContent":["/*\r\nThis function return a session string by parsing cookie value of incoming request.\r\n */\r\nimport { useRouter } from \"next/router\";\r\nimport { APIStatus } from \"./common\";\r\n\r\nexport function getSessionToken(ctx, cookieName) {\r\n  cookieName = cookieName || \"session_token\";\r\n  let sessionStr = ctx.req && ctx.req.headers.cookie;\r\n  let session = undefined;\r\n  if (sessionStr) {\r\n    sessionStr.split(\";\").forEach((cookie) => {\r\n      let i = cookie.indexOf(\"=\");\r\n      let name = cookie.substr(0, i).trim();\r\n      let value = cookie.substr(i + 1).trim();\r\n      if (name == cookieName) {\r\n        session = value;\r\n        return false;\r\n      }\r\n    });\r\n  }\r\n  return session;\r\n}\r\n\r\nasync function getLoggedUserInfo(ctx) {\r\n  let session = getSessionToken(ctx);\r\n\r\n  // if there is not cookie with \"session_token\" name\r\n  let res = ctx.res;\r\n  if (!session || session === \"deleted\") {\r\n    session = getSessionToken(ctx, \"remember_me\");\r\n    if (!session || session === \"deleted\") {\r\n      res.setHeader(\"location\", \"/login?url=\" + escape(ctx.req.url));\r\n      res.statusCode = 302;\r\n      res.end();\r\n      return { props: { loggedIn: false } };\r\n    }\r\n\r\n    res.setHeader(\"set-cookie\", `session_token=${session}; Path=/; HttpOnly`);\r\n  }\r\n\r\n  // if there is value\r\n  let req = {\r\n    method: \"GET\",\r\n    headers: {\r\n      Authorization: `Bearer ${session}`,\r\n      \"User-Agent\": ctx.req.headers[\"user-agent\"],\r\n      \"X-Forwarded-For\": ctx.req.headers[\"x-forwarded-for\"],\r\n    },\r\n  };\r\n  let url = process.env.API_HOST + \"/core/account/v1/me?getPermissions=true\";\r\n  return await fetch(url, req);\r\n}\r\n\r\n/**\r\n * This function is used by injecting to getServerSideProps of pages.\r\n * @param ctx\r\n * @param callback\r\n * @returns {Promise<*|{props: {loggedIn: boolean}}>}\r\n */\r\nexport async function doWithLoggedInUser(ctx, callback) {\r\n  // let result = await getLoggedUserInfo(ctx)\r\n  // let userInfo = await result.json()\r\n\r\n  // // must get user info successful before do anything else\r\n  // // console.log(userInfo)\r\n  // if (userInfo.status !== APIStatus.OK) {\r\n  //     return { props: { loggedIn: false } }\r\n  // }\r\n\r\n  // // check temp password\r\n  // let source = userInfo.data[0]\r\n  // let account = source.account\r\n\r\n  // if (!ctx.req.url.startsWith('/profile') && account.isTempPassword) {\r\n  //     if (typeof window === \"undefined\") {\r\n  //         let res = ctx.res\r\n  //         res.setHeader(\"location\", \"/profile\");\r\n  //         res.statusCode = 302;\r\n  //         res.end();\r\n  //     }\r\n  //     return { props: { loggedIn: true, loggedInUserInfo: source } }\r\n  // }\r\n\r\n  let result = callback(ctx);\r\n  // // wait for page promise\r\n  if (result && result instanceof Promise) {\r\n    result = await result;\r\n  }\r\n\r\n  // // set loggedIn = true if is is undefined\r\n  result = result || {};\r\n  result.props = result.props || {};\r\n  // result.props.loggedInUserInfo = userInfo.data[0]\r\n  // if (typeof result.props.loggedIn == \"undefined\") {\r\n  result.props.loggedIn = true;\r\n  // }\r\n  return result;\r\n}\r\n\r\n/**\r\n * This function is used by injecting to render function of pages.\r\n * @param props\r\n * @param callback\r\n * @returns {null|*}\r\n */\r\nexport function renderWithLoggedInUser(props, callback) {\r\n  let router = useRouter();\r\n\r\n  // if logged in\r\n  if (props.loggedIn !== false) {\r\n    // validate permissions\r\n    let source = props.loggedInUserInfo;\r\n\r\n    if (source) {\r\n      // check temp password\r\n      if (\r\n        !router.asPath.startsWith(\"/profile\") &&\r\n        source.account &&\r\n        source.account.isTempPassword\r\n      ) {\r\n        if (typeof window != \"undefined\") {\r\n          window.location.href = \"/profile\";\r\n        }\r\n\r\n        return callback(props);\r\n      }\r\n    }\r\n\r\n    return callback(props) || null;\r\n  }\r\n\r\n  // if not\r\n  else {\r\n    // do hard redirect to /login\r\n    if (typeof window != \"undefined\") {\r\n      window.location.href = \"/login?url=\" + router.asPath;\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\n/**\r\n *\r\n */\r\nexport async function doLogout() {\r\n  return await fetch(\"/backend/core/account/v1/logout\", {\r\n    method: \"PUT\",\r\n  });\r\n}\r\n\r\nfunction comparePath(input, permission) {\r\n  if (permission.startsWith(\"=\")) {\r\n    if (input === permission.substr(1)) {\r\n      return true;\r\n    }\r\n  } else if (input.startsWith(permission)) {\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function acceptedScreenPath(userInfo, path) {\r\n  if (!userInfo) {\r\n    return false;\r\n  }\r\n  if (path == \"/\" || path == \"/profile\") {\r\n    return true;\r\n  }\r\n  let screens = userInfo.screens;\r\n  let userRoles = userInfo.userRoles;\r\n  let accepted = false;\r\n  if (screens) {\r\n    for (let i = 0; i < screens.length; i++) {\r\n      if (screens[i].indexOf(\":departmentCode\") >= 0) {\r\n        for (let j = 0; userRoles && j < userRoles.length; j++) {\r\n          let normalizedPath = screens[i].replace(\r\n            \":departmentCode\",\r\n            userRoles[j].departmentCode\r\n          );\r\n          if (comparePath(path, normalizedPath)) {\r\n            accepted = true;\r\n            break;\r\n          }\r\n        }\r\n      } else {\r\n        if (comparePath(path, screens[i])) {\r\n          accepted = true;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return accepted;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}