{"ast":null,"code":"import _regeneratorRuntime from \"D:/Learning/Learning/HKI_NamTu/MoHinhHoaPhanMem/KTXSHOP/Source/FE-KTXSHOP-SELLER/node_modules/next/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"D:/Learning/Learning/HKI_NamTu/MoHinhHoaPhanMem/KTXSHOP/Source/FE-KTXSHOP-SELLER/node_modules/next/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\nvar _s = $RefreshSig$();\n\n/*\r\nThis function return a session string by parsing cookie value of incoming request.\r\n */\nimport { useRouter } from \"next/router\";\nimport { APIStatus } from \"./common\";\nexport function getSessionToken(ctx, cookieName) {\n  cookieName = cookieName || \"session_token\";\n  var sessionStr = ctx.req && ctx.req.headers.cookie;\n  var session = undefined;\n\n  if (sessionStr) {\n    sessionStr.split(\";\").forEach(function (cookie) {\n      var i = cookie.indexOf(\"=\");\n      var name = cookie.substr(0, i).trim();\n      var value = cookie.substr(i + 1).trim();\n\n      if (name == cookieName) {\n        session = value;\n        return false;\n      }\n    });\n  }\n\n  return session;\n}\n\nfunction getLoggedUserInfo(_x) {\n  return _getLoggedUserInfo.apply(this, arguments);\n}\n/**\r\n * This function is used by injecting to getServerSideProps of pages.\r\n * @param ctx\r\n * @param callback\r\n * @returns {Promise<*|{props: {loggedIn: boolean}}>}\r\n */\n\n\nfunction _getLoggedUserInfo() {\n  _getLoggedUserInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(ctx) {\n    var session, res, req, url;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            session = getSessionToken(ctx); // if there is not cookie with \"session_token\" name\n\n            res = ctx.res;\n\n            if (!(!session || session === \"deleted\")) {\n              _context.next = 10;\n              break;\n            }\n\n            session = getSessionToken(ctx, \"remember_me\");\n\n            if (!(!session || session === \"deleted\")) {\n              _context.next = 9;\n              break;\n            }\n\n            res.setHeader(\"location\", \"/login?url=\" + escape(ctx.req.url));\n            res.statusCode = 302;\n            res.end();\n            return _context.abrupt(\"return\", {\n              props: {\n                loggedIn: false\n              }\n            });\n\n          case 9:\n            res.setHeader(\"set-cookie\", \"session_token=\".concat(session, \"; Path=/; HttpOnly\"));\n\n          case 10:\n            // if there is value\n            req = {\n              method: \"GET\",\n              headers: {\n                \"Authorization\": \"Bearer \".concat(session),\n                \"User-Agent\": ctx.req.headers['user-agent'],\n                'X-Forwarded-For': ctx.req.headers['x-forwarded-for']\n              }\n            };\n            url = process.env.API_HOST + \"/core/account/v1/me?getPermissions=true\";\n            _context.next = 14;\n            return fetch(url, req);\n\n          case 14:\n            return _context.abrupt(\"return\", _context.sent);\n\n          case 15:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _getLoggedUserInfo.apply(this, arguments);\n}\n\nexport function doWithLoggedInUser(_x2, _x3) {\n  return _doWithLoggedInUser.apply(this, arguments);\n}\n/**\r\n * This function is used by injecting to render function of pages.\r\n * @param props\r\n * @param callback\r\n * @returns {null|*}\r\n */\n\nfunction _doWithLoggedInUser() {\n  _doWithLoggedInUser = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(ctx, callback) {\n    var result;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            // let result = await getLoggedUserInfo(ctx)\n            // let userInfo = await result.json()\n            // // must get user info successful before do anything else\n            // // console.log(userInfo)\n            // if (userInfo.status !== APIStatus.OK) {\n            //     return { props: { loggedIn: false } }\n            // }\n            // // check temp password\n            // let source = userInfo.data[0]\n            // let account = source.account\n            // if (!ctx.req.url.startsWith('/profile') && account.isTempPassword) {\n            //     if (typeof window === \"undefined\") {\n            //         let res = ctx.res\n            //         res.setHeader(\"location\", \"/profile\");\n            //         res.statusCode = 302;\n            //         res.end();\n            //     }\n            //     return { props: { loggedIn: true, loggedInUserInfo: source } }\n            // }\n            result = callback(ctx); // // wait for page promise\n\n            if (!(result && result instanceof Promise)) {\n              _context2.next = 5;\n              break;\n            }\n\n            _context2.next = 4;\n            return result;\n\n          case 4:\n            result = _context2.sent;\n\n          case 5:\n            // // set loggedIn = true if is is undefined\n            result = result || {};\n            result.props = result.props || {}; // result.props.loggedInUserInfo = userInfo.data[0]\n            // if (typeof result.props.loggedIn == \"undefined\") {\n\n            result.props.loggedIn = true; // }\n\n            return _context2.abrupt(\"return\", result);\n\n          case 9:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _doWithLoggedInUser.apply(this, arguments);\n}\n\nexport function renderWithLoggedInUser(props, callback) {\n  _s();\n\n  var router = useRouter();\n  cons; // if logged in\n\n  if (props.loggedIn !== false) {\n    // validate permissions\n    var source = props.loggedInUserInfo;\n\n    if (source) {\n      // check temp password\n      if (!router.asPath.startsWith(\"/profile\") && source.account && source.account.isTempPassword) {\n        if (true) {\n          window.location.href = \"/profile\";\n        }\n\n        return callback(props);\n      }\n    }\n\n    return callback(props) || null;\n  } // if not\n  else {\n      // do hard redirect to /login\n      if (true) {\n        window.location.href = \"/login?url=\" + router.asPath;\n      }\n    }\n\n  return null;\n}\n/**\r\n * \r\n */\n\n_s(renderWithLoggedInUser, \"fN7XvhJ+p5oE6+Xlo0NJmXpxjC8=\", false, function () {\n  return [useRouter];\n});\n\nexport function doLogout() {\n  return _doLogout.apply(this, arguments);\n}\n\nfunction _doLogout() {\n  _doLogout = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.next = 2;\n            return fetch(\"/backend/core/account/v1/logout\", {\n              method: \"PUT\"\n            });\n\n          case 2:\n            return _context3.abrupt(\"return\", _context3.sent);\n\n          case 3:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _doLogout.apply(this, arguments);\n}\n\nfunction comparePath(input, permission) {\n  if (permission.startsWith(\"=\")) {\n    if (input === permission.substr(1)) {\n      return true;\n    }\n  } else if (input.startsWith(permission)) {\n    return true;\n  }\n\n  return false;\n}\n\nexport function acceptedScreenPath(userInfo, path) {\n  if (!userInfo) {\n    return false;\n  }\n\n  if (path == \"/\" || path == \"/profile\") {\n    return true;\n  }\n\n  var screens = userInfo.screens;\n  var userRoles = userInfo.userRoles;\n  var accepted = false;\n\n  if (screens) {\n    for (var i = 0; i < screens.length; i++) {\n      if (screens[i].indexOf(\":departmentCode\") >= 0) {\n        for (var j = 0; userRoles && j < userRoles.length; j++) {\n          var normalizedPath = screens[i].replace(\":departmentCode\", userRoles[j].departmentCode);\n\n          if (comparePath(path, normalizedPath)) {\n            accepted = true;\n            break;\n          }\n        }\n      } else {\n        if (comparePath(path, screens[i])) {\n          accepted = true;\n          break;\n        }\n      }\n    }\n  }\n\n  return accepted;\n}","map":{"version":3,"sources":["D:/Learning/Learning/HKI_NamTu/MoHinhHoaPhanMem/KTXSHOP/Source/FE-KTXSHOP-SELLER/lib/login.js"],"names":["useRouter","APIStatus","getSessionToken","ctx","cookieName","sessionStr","req","headers","cookie","session","undefined","split","forEach","i","indexOf","name","substr","trim","value","getLoggedUserInfo","res","setHeader","escape","url","statusCode","end","props","loggedIn","method","process","env","API_HOST","fetch","doWithLoggedInUser","callback","result","Promise","renderWithLoggedInUser","router","cons","source","loggedInUserInfo","asPath","startsWith","account","isTempPassword","window","location","href","doLogout","comparePath","input","permission","acceptedScreenPath","userInfo","path","screens","userRoles","accepted","length","j","normalizedPath","replace","departmentCode"],"mappings":"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","sourcesContent":["/*\r\nThis function return a session string by parsing cookie value of incoming request.\r\n */\r\nimport { useRouter } from \"next/router\";\r\nimport { APIStatus } from \"./common\";\r\n\r\nexport function getSessionToken(ctx, cookieName) {\r\n    cookieName = cookieName || \"session_token\"\r\n    let sessionStr = ctx.req && ctx.req.headers.cookie\r\n    let session = undefined\r\n    if (sessionStr) {\r\n        sessionStr.split(\";\").forEach((cookie) => {\r\n            let i = cookie.indexOf(\"=\")\r\n            let name = cookie.substr(0, i).trim()\r\n            let value = cookie.substr(i + 1).trim()\r\n            if (name == cookieName) {\r\n                session = value\r\n                return false\r\n            }\r\n        })\r\n    }\r\n    return session\r\n}\r\n\r\nasync function getLoggedUserInfo(ctx) {\r\n    let session = getSessionToken(ctx)\r\n\r\n    // if there is not cookie with \"session_token\" name\r\n    let res = ctx.res\r\n    if (!session || session === \"deleted\") {\r\n        session = getSessionToken(ctx, \"remember_me\")\r\n        if (!session || session === \"deleted\") {\r\n            res.setHeader(\"location\", \"/login?url=\" + escape(ctx.req.url));\r\n            res.statusCode = 302;\r\n            res.end();\r\n            return { props: { loggedIn: false } }\r\n        }\r\n\r\n        res.setHeader(\"set-cookie\", `session_token=${session}; Path=/; HttpOnly`)\r\n    }\r\n\r\n    // if there is value\r\n    let req = {\r\n        method: \"GET\",\r\n        headers: {\r\n            \"Authorization\": `Bearer ${session}`,\r\n            \"User-Agent\": ctx.req.headers['user-agent'],\r\n            'X-Forwarded-For': ctx.req.headers['x-forwarded-for']\r\n        }\r\n    }\r\n    let url = process.env.API_HOST + \"/core/account/v1/me?getPermissions=true\"\r\n    return await fetch(url, req)\r\n}\r\n\r\n/**\r\n * This function is used by injecting to getServerSideProps of pages.\r\n * @param ctx\r\n * @param callback\r\n * @returns {Promise<*|{props: {loggedIn: boolean}}>}\r\n */\r\nexport async function doWithLoggedInUser(ctx, callback) {\r\n    // let result = await getLoggedUserInfo(ctx)\r\n    // let userInfo = await result.json()\r\n\r\n    // // must get user info successful before do anything else\r\n    // // console.log(userInfo)\r\n    // if (userInfo.status !== APIStatus.OK) {\r\n    //     return { props: { loggedIn: false } }\r\n    // }\r\n\r\n    // // check temp password\r\n    // let source = userInfo.data[0]\r\n    // let account = source.account\r\n\r\n    // if (!ctx.req.url.startsWith('/profile') && account.isTempPassword) {\r\n    //     if (typeof window === \"undefined\") {\r\n    //         let res = ctx.res\r\n    //         res.setHeader(\"location\", \"/profile\");\r\n    //         res.statusCode = 302;\r\n    //         res.end();\r\n    //     }\r\n    //     return { props: { loggedIn: true, loggedInUserInfo: source } }\r\n    // }\r\n\r\n    let result = callback(ctx)\r\n    // // wait for page promise\r\n    if (result && result instanceof Promise) {\r\n        result = await result\r\n    }\r\n\r\n    // // set loggedIn = true if is is undefined\r\n    result = result || {}\r\n    result.props = result.props || {}\r\n    // result.props.loggedInUserInfo = userInfo.data[0]\r\n    // if (typeof result.props.loggedIn == \"undefined\") {\r\n    result.props.loggedIn = true\r\n    // }\r\n    return result\r\n}\r\n\r\n/**\r\n * This function is used by injecting to render function of pages.\r\n * @param props\r\n * @param callback\r\n * @returns {null|*}\r\n */\r\nexport function renderWithLoggedInUser(props, callback) {\r\n\r\n    let router = useRouter()\r\n\r\n    cons\r\n\r\n    // if logged in\r\n    if (props.loggedIn !== false) {\r\n        // validate permissions\r\n        let source = props.loggedInUserInfo\r\n        if (source) {\r\n            // check temp password\r\n            if (!router.asPath.startsWith(\"/profile\")\r\n                && source.account && source.account.isTempPassword) {\r\n                if (typeof window != \"undefined\") {\r\n                    window.location.href = \"/profile\"\r\n                }\r\n\r\n                return callback(props)\r\n            }\r\n\r\n\r\n        }\r\n\r\n        return callback(props) || null\r\n    }\r\n\r\n    // if not\r\n    else {\r\n\r\n\r\n\r\n        // do hard redirect to /login\r\n        if (typeof window != \"undefined\") {\r\n            window.location.href = \"/login?url=\" + router.asPath\r\n        }\r\n    }\r\n\r\n    return null\r\n}\r\n\r\n/**\r\n * \r\n */\r\nexport async function doLogout() {\r\n    return await fetch(\"/backend/core/account/v1/logout\", {\r\n        method: \"PUT\"\r\n    })\r\n}\r\n\r\n\r\nfunction comparePath(input, permission) {\r\n    if (permission.startsWith(\"=\")) {\r\n        if (input === permission.substr(1)) {\r\n            return true\r\n        }\r\n    } else if (input.startsWith(permission)) {\r\n        return true\r\n    }\r\n    return false\r\n}\r\n\r\nexport function acceptedScreenPath(userInfo, path) {\r\n    if (!userInfo) {\r\n        return false\r\n    }\r\n    if (path == \"/\" || path == \"/profile\") {\r\n        return true\r\n    }\r\n    let screens = userInfo.screens\r\n    let userRoles = userInfo.userRoles\r\n    let accepted = false\r\n    if (screens) {\r\n        for (let i = 0; i < screens.length; i++) {\r\n            if (screens[i].indexOf(\":departmentCode\") >= 0) {\r\n                for (let j = 0; userRoles && j < userRoles.length; j++) {\r\n                    let normalizedPath = screens[i].replace(\":departmentCode\", userRoles[j].departmentCode)\r\n                    if (comparePath(path, normalizedPath)) {\r\n                        accepted = true\r\n                        break\r\n                    }\r\n                }\r\n            } else {\r\n                if (comparePath(path, screens[i])) {\r\n                    accepted = true\r\n                    break\r\n                }\r\n            }\r\n\r\n\r\n        }\r\n    }\r\n    return accepted\r\n}\r\n\r\n"]},"metadata":{},"sourceType":"module"}